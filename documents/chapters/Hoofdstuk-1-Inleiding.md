# Hoofdstuk 1 - Inleiding

## 1.1 Aanleiding

Stelt u zich eens voor: u loopt stage als junior software engineer bij een techreus. Voor een project moet er digitaal een grote lijst met elementen numeriek gesorteerd worden. Aan u de taak om hier een oplossing voor te bedenken die niet al te veel tijd in beslag neemt. Over deze lijst weten we niet veel. De omvang en geordendheid van de lijst varieert immers per gebruiker en wordt bovendien elke vijf bijgewerkt met nieuwe gegevens. Aangezien u bent afgestudeerd weet u dat u dit probleem kunt oplossen met behulp van een sorteeralgoritme. Dit is, zoals de naam al laat vermoeden, een algoritme die elementen van een lijst in een bepaalde volgorde plaatst. Als u kijkt in de bibliotheek van beschikbare sorteeralgoritmen van het project, ziet u de volgende algoritmen: Selection Sort, Bubble Sort, Insertion Sort, Merge Sort, Quick Sort en Heap Sort. De vraag die nu misschien in u opkomt is ‘Welk sorteeralgoritme moet ik kiezen?’. Als dat niet het geval is en u op intuïtie voor bijvoorbeeld Quick Sort kiest, neem ik dat u niet kwalijk. ‘Ze bereiken tenslotte allemaal hetzelfde doel’. Uw begint toch te twijfelen en besluit om een onderzoek uit te voeren waarin u de tijd van de verschillende algoritmen vergelijkt.

---

[hier de benchmarks]
Op basis van deze benchmarks kiest u voor … (de snelste).
Uw begeleider stelt voor om uw oplossing op grote schaal te testen in een testomgeving. De gegevens komen uit productie en zijn geanonimiseerd.
Tijdens het testen ziet het er naar uit dat uw oplossing perfect aan de eisen voldoet. Het sorteerproces verloopt snel en de gegevens zijn netjes gesorteerd. De leidinggevende lanceert uw oplossing naar productie. Na een laatste check op productie oogt het goed.
Een half uurtje later wordt u leidinggevende gebeld door... De persoon vertelt dat er een relatief grote stijging is van het geheugengebruik van de server.
De applicatie wordt gerollbacked.
Samen met uw leidinggevende bekijkt u uw oplossing. Hij stelt voor om HeapSort te gebruiken.

Computers mogen dan ongelooflijk snel zijn in het manipuleren, verplaatsen en bekijken van gegevens, maar wanneer de hoeveelheid gegevens zo groot is, zal het als noch veel te lang duren om de gegevens te onderzoeken. Niet echt praktisch wanneer je bijvoorbeeld op de schaal van bedrijven als Amazon, Microsoft, Google en Twitter opereert. Deze grote bedrijven verwerken routinematig miljarden gegevens per dag en in sommige gevallen per minuut. De oplossing hiervoor is het gebruik maken van een beter algoritme die grote hoeveelheden gegevens kan doornemen in een redelijke tijdsduur.

---


# 1.2 Afbakening

# 1.3 Hoofdvraag en deelvraag

# 1.4 Methodiek en bronnen

---

### Bronnen

| Auteur | Jaartal | Link |
|--------|---------|------|
| _n.v.t._ | _n.v.t._ | [https://nl.wix.com/about/us](https://nl.wix.com/about/us) |
| University of Cantebury, New Zealand | _n.v.t._ | [https://www.csfieldguide.org.nz/en/chapters/introduction/](https://www.csfieldguide.org.nz/en/chapters/introduction/) |
