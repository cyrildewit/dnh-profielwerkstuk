# Hoofdstuk 1 - Inleiding

## 1.1 Aanleiding

Stelt u zich eens voor: u loopt stage als junior software engineer bij een techreus. Voor een project moet er digitaal een grote lijst met elementen numeriek gesorteerd worden. Aan u de taak om hier een oplossing voor te bedenken die niet al te veel tijd in beslag neemt. Over deze lijst weten we niet veel. De omvang en geordendheid van de lijst varieert immers per gebruiker en wordt bovendien elke vijf bijgewerkt met nieuwe gegevens. Aangezien u bent afgestudeerd weet u dat u dit probleem kunt oplossen met behulp van een sorteeralgoritme. Dit is, zoals de naam al laat vermoeden, een algoritme die elementen van een lijst in een bepaalde volgorde plaatst. Als u kijkt in de bibliotheek van beschikbare sorteeralgoritmen van het project, ziet u de volgende algoritmen: Selection Sort, Bubble Sort, Insertion Sort, Merge Sort, Quick Sort en Heap Sort. De vraag die nu misschien in u opkomt is ‘Welk sorteeralgoritme moet ik kiezen?’. Als dat niet het geval is en u op intuïtie voor bijvoorbeeld Quick Sort kiest, neem ik dat u niet kwalijk. ‘Ze bereiken tenslotte allemaal hetzelfde doel’. Uw begint toch te twijfelen en besluit om een onderzoek uit te voeren waarin u de tijd van de verschillende algoritmen vergelijkt.
[hier de benchmarks]
Op basis van deze benchmarks kiest u voor … (de snelste).
Uw begeleider stelt voor om uw oplossing op grote schaal te testen in een testopmgeving. De gegevens komen uit productie en zijn geanonamiseerd.
Tijdens het testen ziet het er naar uit dat uw oplossing perfect aan de eisen voldoet. Het sorteerproces verloopt snel en de gegevens zijn netjes gesorteerd. De leidinggevende lanceert uw oplossing naar productie. Na een laaste check op productie oogt het goed.
Een half uurtje later wordt u leidinggevende gebeld door … . De persoon vertelt dat er een relatief grote stijging is van het geheugengebruik van de server.
De applicatie wordt gerollbacked .
Samen met uw leidinggevende bekijkt u uw oplossing. Hij stelt voor om HeapSort te gebruiken.


zouden er meerdere sorteeralgoritmen ontwikkeld worden, als ze allemaal hetzelfde doel bereiken?


Stelt u zich eens voor dat u werkzaam bent als software engineer bij een techreus. Voor een project moet u een grote lijst met elementen numeriek sorteren. De omvang en geordendheid van de lijst varieert per situatie. Bovendien mag het sorteerproces niet al te lang duren. Aangezien u bent afgestudeerd weet u dat u dit probleem kunt oplossen met behulp van een sorteeralgoritme. Zoals de naam al laat vermoeden, is dit een algoritme die elementen van een lijst in een bepaalde volgorde plaatst. Enkele voorbeelden van sorteeralgoritmen zijn: Selection Sort, Bubble Sort, Merge Sort, Quick Sort en Heap Sort.
De vraag die nu misschien in u opkomt zou kunnen zijn ‘Welk sorteeralgoritme moet ik kiezen?’. Als dat niet het geval is en u op intuïtie voor bijvoorbeeld Quick Sort hebt gekozen, neem ik het u niet kwalijk. Waarom zijn er überhaupt meerdere algoritmen mogelijk?


of ‘Welk algoritme presteert het best?’. Als dat niet het geval, neem ik het u niet kwalijk. Waarom zijn er uberhaupt meerdere sorteeral
Deze vragen

Selection Sort, Bubble Sort, Insertion Sort, Merge Sort, Quick Sort en Heap Sort zijn allemaal voorbeelden van algoritmen die als doel hebben om elementen van een lijst in een bepaalde volgorde te plaatsen. Zulke algoritmen worden ook wel sorteeralgoritmen genoemd.
Computers mogen dan ongelooflijk snel zijn in het manipuleren, verplaatsen en bekijken van gegevens, maar wanneer de hoeveelheid gegevens zo groot is, zal het als noch veel te lang duren om de gegevens te onderzoeken. Niet echt praktisch wanneer je bijvoorbeeld op de schaal van bedrijven als Amazon, Microsoft, Google en Twitter opereert. Deze grote bedrijven verwerken routinematig miljarden gegevens per dag en in sommige gevallen per minuut. De oplossing hiervoor is het gebruik maken van een beter algoritme die grote hoeveelheden gegevens kan doornemen in een redelijke tijdsduur.


Als we logisch naar deze omschrijving kijken zouden we kunnen stellen dat deze algoritmen hetzelfde resultaat behalen.


Ze kunnen dus allemaal hetzelfde doel behalen, namelijk






Al snel stuitte ik op het idee om onderzoek te doen naar ‘algoritmen’. Algoritmen spelen een belangrijke rol in dit informatietijdperk.


# 1.2 Afbakening

Het domein van algoritmen reikt heel ver. Zo vallen algoritmen hieronder die een specifiek probleem oplossen, zoals Google’s zoekalgoritme (PageRank) of een algoritme die banktransactie afhandelt. Er zijn ook algoritmen die een veel breder doeleinde hebben. Neem als voorbeeld

# 1.3 Hoofdvraag en deelvraag

# 1.4 Methodiek en bronnen

---

### Bronnen

| Auteur | Jaartal | Link |
|--------|---------|------|
| _n.v.t._ | _n.v.t._ | [https://nl.wix.com/about/us](https://nl.wix.com/about/us) |
| University of Cantebury, New Zealand | _n.v.t._ | [https://www.csfieldguide.org.nz/en/chapters/introduction/](https://www.csfieldguide.org.nz/en/chapters/introduction/) |
